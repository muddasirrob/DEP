import argparse

# Game Constants
RED_POINTS = 2
BLUE_POINTS = 3

class NimGame:
    def __init__(self, red_marbles, blue_marbles, version, first_player, search_depth):
        self.red_marbles = red_marbles
        self.blue_marbles = blue_marbles
        self.version = version
        self.current_player = first_player
        self.search_depth = search_depth

    def is_game_over(self):
        return self.red_marbles == 0 or self.blue_marbles == 0

    def get_winner(self):
        if self.version == "standard":
            return "computer" if self.current_player == "human" else "human"
        else:
            return "human" if self.current_player == "human" else "computer"

    def get_score(self):
        return self.red_marbles * RED_POINTS + self.blue_marbles * BLUE_POINTS

    def make_move(self, pile, amount):
        if pile == "red":
            self.red_marbles -= amount
        elif pile == "blue":
            self.blue_marbles -= amount

    def undo_move(self, pile, amount):
        if pile == "red":
            self.red_marbles += amount
        elif pile == "blue":
            self.blue_marbles += amount

    def minmax(self, depth, alpha, beta, maximizing_player):
        if self.is_game_over() or depth == 0:
            return self.evaluate()

        if maximizing_player:
            max_eval = float('-inf')
            for move in self.get_possible_moves():
                self.make_move(move[0], move[1])
                eval = self.minmax(depth - 1, alpha, beta, False)
                self.undo_move(move[0], move[1])
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break
            return max_eval
        else:
            min_eval = float('inf')
            for move in self.get_possible_moves():
                self.make_move(move[0], move[1])
                eval = self.minmax(depth - 1, alpha, beta, True)
                self.undo_move(move[0], move[1])
                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta <= alpha:
                    break
            return min_eval

    def evaluate(self):
        if self.is_game_over():
            if self.version == "standard":
                if self.get_winner() == "human":
                    return float('-inf')
                else:
                    return float('inf')
            else:
                if self.get_winner() == "human":
                    return float('inf')
                else:
                    return float('-inf')
        return self.get_score()

    def get_possible_moves(self):
        moves = []
        for i in range(1, self.red_marbles + 1):
            moves.append(("red", i))
        for i in range(1, self.blue_marbles + 1):
            moves.append(("blue", i))
        return moves

    def computer_move(self):
        best_move = None
        best_value = float('-inf')
        for move in self.get_possible_moves():
            self.make_move(move[0], move[1])
            move_value = self.minmax(self.search_depth - 1, float('-inf'), float('inf'), False)
            self.undo_move(move[0], move[1])
            if move_value > best_value:
                best_value = move_value
                best_move = move
        if best_move is not None:
            self.make_move(best_move[0], best_move[1])
        return best_move

    def human_move(self, pile, amount):
        self.make_move(pile, amount)

def main():
    parser = argparse.ArgumentParser(description="Red-Blue Nim Game")
    parser.add_argument("--red", type=int, help="Number of red marbles", default=10)
    parser.add_argument("--blue", type=int, help="Number of blue marbles", default=10)
    parser.add_argument("--version", type=str, choices=["standard", "misere"], help="Game version", default="misere")
    parser.add_argument("--first_player", type=str, choices=["human", "computer"], help="First player", default="human")
    parser.add_argument("--search_depth", type=int, help="AI search depth", default=3)

    args = parser.parse_args()

    game = NimGame(args.red, args.blue, args.version, args.first_player, args.search_depth)

    while not game.is_game_over():
        if game.current_player == "human":
            print(f"Red marbles: {game.red_marbles}, Blue marbles: {game.blue_marbles}")
            pile = input("Enter pile (red/blue): ").strip().lower()
            amount = int(input("Enter amount: ").strip())
            if (pile, amount) not in game.get_possible_moves():
                print("Invalid move. Try again.")
                continue
            game.human_move(pile, amount)
            game.current_player = "computer"
        else:
            move = game.computer_move()
            if move is None:
                print("No valid moves available. Game Over!")
                break
            print(f"Computer moved {move[1]} from {move[0]} pile.")
            game.current_player = "human"

    print("Game over!")
    print(f"Winner: {game.get_winner()}")
    print(f"Final Score: {game.get_score()}")

if __name__ == "__main__":
    main()

